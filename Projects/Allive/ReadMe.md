# Allive - í•¨ê»˜í•˜ëŠ” ì„¸ìƒ ì˜¬ë¦¬ë¸Œ

## Intro. í”„ë¡œì íŠ¸ ì†Œê°œ

ì˜¬ë¦¬ë¸Œ í”„ë¡œì íŠ¸ ì†Œê°œ ë° í”„ë¡ íŠ¸ ì—”ë“œ ê°œë°œ íšŒê³  ì…ë‹ˆë‹¤ ğŸ˜

í”„ë¡ íŠ¸ì—”ë“œ ê°œë°œí•˜ë©´ì„œ ìˆì—ˆë˜ **í°ê±´ ì—†ê³  ì‚¬ì†Œí•˜ê³  í•˜ì°®ì€ ê³ ë¯¼ì— ëŒ€í•œ íšŒê³ **ë¥¼ ë‚¨ê²¨ë‘ê¸° ìœ„í•¨ ì…ë‹ˆë‹¤ âœï¸

#### ëœë”© í˜ì´ì§€ : [ì˜¬ë¦¬ë¸Œ ëœë”© í˜ì´ì§€ ë§í¬](https://all-live.github.io/)

TODO: ëª¨ë°”ì¼ ëŒ€ì‘

#### ì˜¬ë¦¬ë¸ŒëŠ” ì–´ë–¤ í”„ë¡œì íŠ¸ ì¸ê°€ìš” ğŸ™‹ğŸ»

ì˜¬ë¦¬ë¸Œ í”„ë¡œì íŠ¸ (**Allive**, **All Live Together**)ëŠ” 2021ë…„ 3ì›”ë¶€í„° ê¸°íš ë° ê¸°ìˆ  ìŠ¤íƒ ìŠ¤í„°ë””, 9ì›”ë¶€í„° ë³¸ê²©ì ì¸ ê°œë°œì— ë“¤ì–´ê°„ **ì¬ëŠ¥ë‚˜ëˆ” ì–´í”Œ** í”„ë¡œì íŠ¸ ì…ë‹ˆë‹¤.

ëŒ€í•™êµ 4í•™ë…„ ê°œë°œì 2ëª…ì´ì„œ í•™ê³¼ ê³µë¶€ ë° íšŒì‚¬ ì—…ë¬´ì™€ ë³‘í–‰í•˜ë©° í‡´ê·¼ í›„, ì£¼ë§ ì‹œê°„ ë“±ì„ í™œìš©í•˜ì—¬ ì—´ì •ì„ ë¶ˆ íƒœìš°ë©° ê°œë°œì¤‘ì¸ í”„ë¡œì íŠ¸ ì…ë‹ˆë‹¤. ğŸ”¥

<div class="center">
  <img src ="./img/allive_guide_3.png" width="300" height="auto">
  <img src ="./img/allive_guide_1.png" width="300" height="auto">
  <img src ="./img/allive_guide_2.png" width="300" height="auto">
</div>

ê°œë°œì ì†Œê°œ ì…ë‹ˆë‹¤.

- ğŸ‘¨ğŸ»â€ğŸ’» í”„ë¡ íŠ¸ ì—”ë“œ ê°œë°œ - ì‹ ì •ì›… [github](https://github.com/JeongShin)

- ğŸ‘¨ğŸ»â€ğŸ’» ë°±ì—”ë“œ ê°œë°œ - ì´ì‹ ìœ¡ [github](https://github.com/leeshinyook)

#### í”„ë¡ íŠ¸ì—”ë“œ App ê¸°ìˆ ìŠ¤íƒ

- React Native

- Styled Components Native

- Recoil js

- Firebase (Cloud Messaging, Crashlytics, Analytics)

#### í”„ë¡ íŠ¸ì—”ë“œ Web ê¸°ìˆ ìŠ¤íƒ

- Next js -> ìŠ¤íƒë§Œ next ì§€ ssr ì€ ì‚¬ìš© ëª»í–ˆìŒ (ì•ˆí–ˆìŒ)..

#### ë°±ì—”ë“œ ê¸°ìˆ ìŠ¤íƒ

- Java Spring

- AWS - elasticsearch

- Swagger

- Serverless Graphql API

#### í”„ë¡œì íŠ¸ ì§„í–‰ìƒí™©

|                     | iOS          | Android       | Web          |
| ------------------- | ------------ | ------------- | ------------ |
| 1ì°¨ ë°°í¬ - ë²„ì „ 1.0 | ë°°í¬ ì™„ë£Œ âœ… | ë°°í¬ ì™„ë£Œ âœ…| ë°°í¬ ì™„ë£Œ âœ…    |
| 2ì°¨ ë°°í¬ - ë²„ì „ 1.1 | 2021.12 ì˜ˆì • | 2021.12 ì˜ˆì •  | 2021.12 ì˜ˆì • |

2ì°¨ ë°°í¬ë¥¼ ë§ˆë¬´ë¦¬ë¡œ í”„ë¡œì íŠ¸ ë§ˆë¬´ë¦¬ ë  ì˜ˆì • ì…ë‹ˆë‹¤.

## Note 1. Serverless Graphql Chat API

ì±„íŒ… êµ¬í˜„ì„ ì•ë‘ê³  í˜‘ì—…ì¤‘ì¸ ë°±ì—”ë“œ ì¹œêµ¬ì—ê²Œ ì±„íŒ… ì„œë²„ë¥¼ ê°œë°œ í•´ë³´ê² ë‹¤ê³  í•˜ê³  í…ŒìŠ¤í¬ë¥¼ ë§¡ì•˜ë‹¤. 

ìŠ¤íƒì€ ì—¬ëŸ¬ê°€ì§€ ê³ ë¯¼ì„ í•˜ë‹¤ê°€ `Appsync` `Aurora postgres` `lambda` ë¡œ êµ¬ì„±ì„ í•˜ì˜€ê³  cdk ì½”ë“œ ì‘ì„± í›„ ë°°í¬ í–ˆë‹¤. ê·¸ëƒ¥ ê°œë°œ ë‹¨ê³„ë¶€í„° ì—´ì •ì ìœ¼ë¡œë‹¤ê°€ ëˆì´ ë§ì´ ë“ ë‹¤.. ğŸ˜µâ€ğŸ’« 

appsync ëŠ” `amplify` ë“±ì„ í†µí•´ì„œ ì‰½ê²Œ ìŠ¤í‚¤ë§ˆë¥¼ ì„¤ê³„í•˜ê³  ìë™ìœ¼ë¡œ ìƒì„±ë˜ëŠ” `resolver` ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆì§€ë§Œ ì»¤ìŠ¤í„°ë§ˆì´ì§•ì´ ì–´ë µê³  ê°œë°œí•˜ë©´ì„œ ì½”ë“œë¥¼ ì§œëŠ” ì‹œê°„ë³´ë‹¤ **aws vtl** ë“± ë¬¸ë²•ì„ ì°¾ì•„ë³´ê±°ë‚˜ stack overflow ë§Œ í•˜ë£¨ì¢…ì¼ ë’¤ì§€ëŠ”ê±°ë³´ë‹¤ lambda ì— ì»¤ìŠ¤í…€ resolver ë¥¼ ì‚¬ìš©í•´ì„œ ì½”ë”©í•˜ëŠ” ì‹œê°„ì„ ë§ì´ ìŸëŠ”ê²Œ ë” ì¢‹ì•˜ê³  ê·¸ë ‡ê²Œ ì‹œì‘í•´ë³´ì•˜ë‹¤. 

ê°œì¸ì ìœ¼ë¡œ aws ë„íê°€ ë„ˆë¬´ ì½ê¸° ì–´ë µë‹¤.. 

### Resolver ğŸ„â€â™‚ï¸

ì•„ë˜ëŠ” ëŒë‹¤ index.ts ì½”ë“œ ì¼ë¶€ì´ë‹¤. ê°ê°ì˜ graphql query ì— resolver í•¨ìˆ˜ë¥¼ ë§¤í•‘ í•´ì£¼ì—ˆë‹¤. ì—¬ê¸°ê¹Œì§„ ì•„ì£¼ ìˆœì¡°ë¡œì› ë‹¤. 

```TS
exports.handler = async (event: AppSyncEvent, _: unknown, callback: (param: unknown) => void) => {
  try {
    const { token } = event.arguments;
    if (!token) throw new Error('TOKEN NOT FOUND');
    const { uid } = jwtDecode<{ uid?: string }>(token);
    if (!uid) throw new Error('USER NOT AUTHENTICATED');

    switch (event.info.fieldName) {
      case 'createMe':
        return await createMe(event.arguments.createMeInput, uid);
      case 'createMessage':
        return await createMessage(event.arguments.messageInput, uid);
      case 'createChatRoom':
        return await createChatRoom(event.arguments.chatroomInput, uid);
      case 'listChatRooms':
        return await listChatRooms(uid);
      case 'listMessages':
        return await listMessages(event.arguments.listMessageInput);
      case 'getChatRoom':
        return await getChatRoom(event.arguments.chatroomId, uid);
      case 'joinChatRoom':
        return await joinChatRoom(event.arguments.chatroomId, uid);
      case 'updateUserChatRoom':
        return await updateUserChatRoom(event.arguments.userChatRoomInput, uid);
      default:
        throw new Error('RESOLVER NOT FOUND');
    }
  } catch (error) {
    console.error(error);
    callback(error);
    return null;
  }
};
```

### Pagination âœ‚ï¸

`listMessages` resolver ì—ì„œ pagination ì„ ì–´ë–»ê²Œ êµ¬í˜„í• ì§€ ê³ ë¯¼ì´ì˜€ë‹¤. ìš°ì„  custom lambda ë¡œ ì‹œì‘í•œ ì´ìƒ ì§ì ‘ êµ¬í˜„í•´ì•¼ í–ˆë‹¤. ê¸°ì¡´ì— Rails Backend ê°œë°œí• ë•Œ 

```RB
  posts = posts.page(cursor)
```

ì™€ ê°™ì´ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ì˜ì¡´í•´ì™”ê³  ì•„ë¬´ë˜ë„ ë°±ì—”ë“œ ê°œë°œì„ ë§ì´ ì•ˆí•´ë³¸ë°ë‹¤ ì¿¼ë¦¬ë¥¼ LIMIT, OFFSET ë“±ì„ ì´ìš©í•´ì„œ êµ¬í˜„í•˜ê¸°ë„ ì• ë§¤í–ˆë‹¤. 

sql ì¿¼ë¦¬ë¥¼ ì§œê¸° ì–´ë ¤ìš´ê±°ë³´ë‹¤ page ë³„ë¡œ ë°ì´í„° ê°€ì ¸ì˜¤ë‹¤ ë„ì¤‘ì— ìƒëŒ€ê°€ ë©”ì‹œì§€ ë³´ë‚´ì„œ ì¶”ê°€ë˜ë©´ ì–´ë–»ê²Œ ì²˜ë¦¬í•´ì•¼í•˜ì§€? 

pagination ì´ ë°€ë¦¼ ì—†ì´ ë˜ë‚˜? ì´ëŸ° ê³ ë¯¼ë“¤ì´ ìˆëŠ”ë° ë‹¹ì¥ ëª¨ë¥´ê² ì–´ì„œ ë‚´ê²Œ ìµìˆ™í•œ js ìª½ì— ë¡œì§ì„ ë” ì§‘ì¤‘í•˜ì—¬ì„œ ì½”ë“œë¥¼ êµ¬í˜„ í•´ë´¤ë‹¤. 

ë°©ë²•ì€ column id ê°’ì„ ì´ìš©í•´ì„œ ê°€ì ¸ì˜¨ ë°ì´í„°ê¹Œì§€ë§Œ limit ìœ¼ë¡œ ìë¥´ê³  ë‹¤ìŒ í˜ì´ì§€ ì •ë³´ì™€ í•¨ê»˜ ë‹¤ìŒìœ¼ë¡œ ì²˜ìŒ ì½ì„ ë°ì´í„°ì˜ id ê°’ì„ ë„˜ê²¨ì£¼ëŠ” ì‹ìœ¼ë¡œ êµ¬í˜„í–ˆë‹¤. 

```TS
async function listMessages(listMessageInput: ListMessagesInput) {
  const { chatroomId, limit, cursor } = listMessageInput;

  const { records } = await db.query(
    `
      SELECT *
      FROM messages
      INNER JOIN users
      ON users.useruid = messages.useruid
      WHERE messages.chatroomid = :chatroomId
      ORDER BY messages.createdat DESC
    `,
    {
      chatroomId,
    },
  );

  // ì¼ë‹¨ chatroomId ê¸°ë°˜ìœ¼ë¡œ ëª¨ë“  ë©”ì‹œì§€ë¥¼ ê¸ì–´ ì˜¨ë‹¤. ë­ ë©”ì‹œì§€ ì •ë§ ë§ì•„ë´ì•¼ ëª‡ë°±ê°œì¯¤ ë í…ë° 
  // ìš°ì„  ìš°ë¦¬ ì„œë¹„ìŠ¤ì—ëŠ” í° ë¬¸ì œê°€ ì—†ìœ¼ë¦¬ë¼ ìƒê° ëœë‹¤. 
  // ì´ì œ js ë‹¨ì—ì„œ pagination ì„ ì²˜ë¦¬

  return paginate<Message>(records, {
    limit,
    cursor,
    column: 'messageid',
    map: mapMessage,
  });
}

// utils.ts

export interface PageInfo {
  nextCursor: string | null;
  hasNextPage: boolean;
  totalCount: number;
}

export interface PaginateResult<Output> {
  pageInfo: PageInfo;
  items: Output[];
}

const paginate = <Output>(records: AnyObject[], params: PaginateParams<Output>): PaginateResult<Output> => {
  const { limit, cursor, column, map } = params;

  let [startIdx, lastIdx] = [-1, -1];

  return records.reduce<PaginateResult<Output>>(
    (acc, curr, index) => {
      if ((!cursor && index === 0) || curr[column] === cursor) {
        [startIdx, lastIdx] = [index, index + limit];
      }

      if (startIdx <= index && index < lastIdx) {
        acc.items.push(map(curr));
      }

      if (index === lastIdx && records[lastIdx]) {
        acc.pageInfo.nextCursor = records[lastIdx][column];
        acc.pageInfo.hasNextPage = true;
      }

      return acc;
    },
    { pageInfo: { nextCursor: null, hasNextPage: false, totalCount: records.length }, items: [] },
  );
};
```

ì‚´ì§ ì•Œê³ ë¦¬ì¦˜ ì§œëŠ” ëŠë‚Œì´ì˜€ì§€ë§Œ ê²°ê³¼ëŠ” ëŒ€ì„±ê³µ ì´ì˜€ë‹¤. 

### ìµœì í™”..? 

cloud watch ë¡œ í™•ì¸ í–ˆì„ë•Œ ëŒ€ë¶€ë¶„ì˜ api ìš”ì²­ì´ 30 ~ 60 ms ë‚´ì— ì²˜ë¦¬ ë˜ì—ˆë‹¤. lambda ê°€ **cold start** ì¼ë•Œ í‰ê·  500ms ì¸ê±¸ ì œì™¸í•˜ë©´ ìƒê°í•œê±°ë³´ë‹¤ ì†ë„ê°€ ë¹¨ë¼ì„œ ì•„ì£¼ ë§Œì¡±ìŠ¤ëŸ¬ì› ë‹¤. 

ë¬¸ì œëŠ” `createMessage` ì—ì„œ ì²˜ë¦¬í•´ì¤˜ì•¼ í• ê²Œ ë§ì•„ì„œ í‰ê·  400 ~ 800 ms ì‘ë‹µ ì†ë„ê°€ ë‚˜ì™”ëŠ”ë°

1. userchatrooms unReadCnt ì»¬ëŸ¼ê°’ ì—…ë°ì´íŠ¸ (ìƒëŒ€ë°© ì½ì§€ ì•Šì€ ìˆ˜)
2. fcm ì²˜ë¦¬
3. chatroom lastMessage, lastMessagedAt ì»¬ëŸ¼ê°’ ì—…ë°ì´íŠ¸

ë¥¼ í•´ì¤˜ì•¼ í–ˆë‹¤. ë¨¼ì € `Promise.all` ì„ í†µí•œ ë³‘ë ¬ì²˜ë¦¬ë¥¼ í•´ì¤¬ì§€ë§Œ ê·¸ë˜ë„ ê·¸ë‚˜ë§ˆ í–¥ìƒëœê²Œ 300ms ~ 500ms ì¸ë° ê²°êµ­ ìœ ì € ì…ì¥ì—ì„œëŠ” ì´ ë˜í•œ ë©”ì‹œì§€ê°€ ë°”ë¡œê°€ì§€ ì•Šê¸° ë•Œë¬¸ì— ë‹µë‹µí•¨ì„ ëŠë‚„ ìˆ˜ ìˆë‹¤ ìƒê° ë˜ì—ˆë‹¤. (ì¼ë‹¨ ë‚˜ëŠ” ë‹µë‹µí–ˆë‹¤). 

```TS
async function createMessage(messageInput: CreateMessageInput, userUid: string) {
  // ìƒëµ
  const message = {
    messageId: messageId || uuid(),
    body,
    userUid,
    createdAt: now,
    chatroomId,
  };

  await Promise.all([
    db.query(
      'INSERT INTO messages (messageid,body,useruid,createdat,chatroomid) VALUES(:messageId,:body,:userUid,:createdAt,:chatroomId)',
      message,
    ),
    db.query(`UPDATE chatrooms SET lastmessage = :body, lastmessageat = :now WHERE chatroomid = :chatroomId`, {
      body,
      now,
      chatroomId,
    }),
    ...mapFcmPromises(chatroom, me, body),
    ...mapUpdateUserChatRoomPromises(chatroom, me),
  ]);

  return { ...message, writer: me };
}
```

ê²°êµ­ ë§ˆì§€ë§‰ ìµœí›„ì˜ ìˆ˜ë‹¨ì€ ì–´ì°¨í”¼ ì„œë²„ì—ì„œ ë¬¸ì œ ì—†ì´ ë©”ì‹œì§€ê°€ ê°„ë‹¤ê³  ê°€ì •í•˜ê³  í”„ë¡ íŠ¸ ë‹¨ì—ì„œ ì²˜ë¦¬ë¥¼ í•´ì¤˜ì•¼ê² ë‹¤ ìƒê°ì„ ë°”ê¿¨ë‹¤. 

```TS
const messageSubmitHandler = useCallback(async ({ body }: MessageBarForm) => {
  try {
    const messageId = uuid.v4();

    const message: Message = {
      writer: {
        userId: `${currentUser.userId}`,
        userUid: currentUser.userUid,
        nickname: currentUser.nickname,
        deviceToken: null,
        profile: null,
      },
      body,
      messageId,
      chatroomId,
      createdAt: Date.now(),
    };
    // ìš°ì„  ë©”ì‹œì§€ê°€ ë¬¸ì œì—†ì´ ìƒê¸°ë¦¬ë¼ ê°€ì •í•˜ê³  message list ì— ì¶”ê°€
    queryClient.setQueryData<PaginateResult<Message> | undefined>(messagesQueryKey, (prev) =>
      prev
        ? {
            ...prev,
            items: [message, ...prev.items],
          }
        : prev,
    );
    // API ìš”ì²­
    await ChatApi.Message.createMessage({ body, chatroomId, messageId });

    // ì„±ê³µí•˜ë©´ createdAt ì„ ê¸°ë°˜ìœ¼ë¡œ ë‹¤ì‹œ sorting í•´ì¤„ ìˆ˜ ìˆì§€ë§Œ ë„ì¤‘ì— ìˆœì„œê°€ ì„ì¼ ì •ë„ë¡œ ì±„íŒ…ì´ í™œë°œí• ê¹Œ
    // ì‹¶ê¸°ë„ í•˜ê³  100 ~ 200 ms ì‚¬ì´ì— ë™ì‹œì— ë³´ë‚´ì§„ ë©”ì‹œì§€ê°€ ì ê¹ ìˆœì„œê°€ ë°”ë€Œì–´ ë³´ì—¬ë„ í¬ê²Œ ì‚¬ìš©ì ê²½í—˜ì„ í•´ì¹˜ì§„ ì•ŠëŠ”ë‹¤ ìƒê°í•œë‹¤. 
  } catch (error) {
    console.error('error', error);
  }
}, []);
```

### Message UI ì²˜ë¦¬ 

ê°œì¸ì ìœ¼ë¡œ ì´ë²ˆ ì±„íŒ…ì„œë²„ ê°œë°œë™ì•ˆ ì œì¼ ì¬ë°Œì—ˆë˜ ë¶€ë¶„.  

RN ì—ì„œ **react-native-gifted-chat** ì´ë¼ëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ìˆê¸´ í•˜ì§€ë§Œ ë˜ ì§ì ‘ êµ¬í˜„í•˜ê¸°ë¡œ ë§ˆìŒ ë¨¹ì—ˆë‹¤. 

ì‚´ì§ ê¹Œë‹¤ë¡œì› ë˜ê²Œ í”„ë¡œí•„ì€ ì˜¬ë¼ê°€ê³  ë‚ ì§œëŠ” ë™ì¼í•˜ë©´ ë‚´ë ¤ê°€ê³  ë“± ì•, ë’¤ ë©”ì‹œì§€ì— ë”°ë¥¸ ë·°ì²˜ë¦¬ì¸ë° 

```TS
const renderItem: ListRenderItem<Message> = useCallback(
  ({ item: currMessage, index }) => {
    const isMyMessage = Number(currMessage.writer.userId) === Number(myUserId);
    const nextMessage = messages[index + 1];
    const prevMessage = messages[index - 1];

    const prevYYYYMd = prevMessage ? format(prevMessage.createdAt * 1, TIME_FORMAT.YYYYMd) : '';
    const currYYYYMd = format(currMessage.createdAt * 1, TIME_FORMAT.YYYYMd);

    const prevHHmm = prevMessage ? format(prevMessage.createdAt * 1, TIME_FORMAT.HHmm) : '';
    const currHHmm = format(currMessage.createdAt * 1, TIME_FORMAT.HHmm);
    const isNextDiffUser = nextMessage ? nextMessage.writer.userId !== currMessage.writer.userId : true;
    const isPrevDiffUser = prevMessage ? prevMessage.writer.userId !== currMessage.writer.userId : true;

    return isMyMessage ? (
      <MyMessageBubble
        message={currMessage}
        currHHmm={currHHmm}
        currYYYYMd={currYYYYMd}
        isNextDiffUser={isPrevDiffUser}
        isHHmmDiff={currHHmm !== prevHHmm || isPrevDiffUser}
        isDiffDate={currYYYYMd !== prevYYYYMd && !!prevMessage}
      />
    ) : (
      <OtherMessageBubble
        message={currMessage}
        currHHmm={currHHmm}
        currYYYYMd={currYYYYMd}
        isNextDiffUser={isNextDiffUser}
        isHHmmDiff={currHHmm !== prevHHmm || isPrevDiffUser}
        isDiffDate={currYYYYMd !== prevYYYYMd && !!prevMessage}
      />
    );
  },
  [messages],
);
```

ìš”ëŸ°ì‹ìœ¼ë¡œ í•œë²ˆ í•´ë´¤ê³  

<div class="center">
  <img src ="./img/chat1.png" width="300" height="auto">
  <img src ="./img/chat2.png" width="300" height="auto">
  <img src ="./img/chat3.png" width="300" height="auto">
</div>

ìƒê°ë³´ë‹¤ ì´ì˜ê²Œ ì˜ë‚˜ì˜¨ë‹¤. ë‚˜ì¤‘ì— ì‹œê°„ë˜ë©´ ì‚¬ì§„ ì—…ë¡œë“œê¹Œì§€ ë¶™ì´ê³  ì‹¶ê¸´í•˜ë‹¤. 

ì´ì œ ë‹¨í†¡ë°© êµ¬í˜„ í•´ì•¼ì§€...

## Note 2. Custom Event

RN í™˜ê²½ì—ì„œ ê°œë°œì„ í•˜ë‹¤ê°€ `Custom Event` ë¥¼ ë°œìƒì‹œì¼œì•¼ í•˜ëŠ” ìƒí™©ì´ ìƒê²¼ë‹¤.

ì¸ìŠ¤íƒ€ê·¸ë¨ê³¼ ê°™ì€ ì•±ì—ì„œ í•˜ë‹¨ íƒ­ì„ ì—¬ëŸ¬ë²ˆ íƒ­í•˜ê±°ë‚˜ ë¡œê³ ë¥¼ ëˆ„ë¥´ëŠ” ê²½ìš° ìŠ¤í¬ë¡¤ì„ ì­‰ ì˜¬ë ¤ì£¼ëŠ” êµ¬í˜„ì„ í•˜ê³  ì‹¶ì—ˆë‹¤.

### ë¬¸ì œì 

- í•˜ë‹¨ íƒ­ ì»´í¬ë„ŒíŠ¸ì™€ ë¦¬ìŠ¤íŠ¸ ì»´í¬ë„ŒíŠ¸ê°€ ì™„ì „íˆ ë¶„ë¦¬ëœ ì»´í¬ë„ŒíŠ¸ì´ê¸° ë•Œë¬¸ì— ì†Œí†µí•  ìˆ˜ ìˆëŠ” êµ¬ì¡°ê°€ ì•„ë‹ˆì˜€ë‹¤.
- Node Module **events** ë¥¼ ì‚¬ìš©í•´ì„œ ì»¤ìŠ¤í…€ ì´ë²¤íŠ¸ë¥¼ ë°œìƒì‹œì¼œ êµ¬í˜„í•˜ê³  ì‹¶ì—ˆì§€ë§Œ React Native í™˜ê²½ì—ì„œëŠ” ê¸°ë³¸ ëª¨ë“ˆì´ ì—†ë‹¤.
- ë‹¤ë¥¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì°¾ì•„ì„œ ì“¸ê¹Œ ê³ ë¯¼ í–ˆì§€ë§Œ ê·¸ëƒ¥ ì»¤ìŠ¤í…€ìœ¼ë¡œ ë§Œë“¤ì–´ ë³´ê¸°ë¡œ ê²°ì •í–ˆë‹¤.
- RN ì½”ì–´ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì œì™¸í•˜ê³ ëŠ” ë‹¤ë¥¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš©ì„ ìµœì†Œí™”í•˜ê¸° ìœ„í•œ ë…¸ë ¥ì´ë‹¤.. ã…ã…

### í•´ê²°ë°©ì•ˆ

ì¼ë‹¨ ê¸°ë³¸ì ì¸ `addEventListener` ì™€ í´ë¦°ì—…ì„ ìœ„í•œ `removeEventListener` ë§Œ ëŸ¬í”„í•˜ê²Œ ì‘ì„±í•´ë³´ì•˜ë‹¤.

```JS
type Callback = (args?: unknown) => Promise<void> | void;

class EventClass {
  private static Listeners = new Map<string, Callback>();

  static addEventListener(name: string, callback: Callback) {
    const [isNameString, isCallbackFn, isExists] = [
      typeof name === 'string',
      typeof callback === 'function',
      EventClass.Listeners.has(name),
    ];

    if (!isNameString || !isCallbackFn || isExists) return;

    EventClass.Listeners.set(name, callback);
  }

  static removeEventListener(name: string) {
    if (typeof name !== 'string') return;
    EventClass.Listeners.delete(name);
  }

  static emit(name: string, args?: unknown) {
    const callback = EventClass.Listeners.get(name);

    if (typeof callback === 'function') {
      callback(args);
    }
  }
}

export default EventClass;
```

ì´ì œ BottomTabs ì—ì„œ ê°™ì€ íƒ­ì„ ë‘ë²ˆ í´ë¦­í•˜ê²Œ ë˜ëŠ” ê²½ìš° ì´ë²¤íŠ¸ë¥¼ ë°œìƒ ì‹œí‚¨ë‹¤.

```JS
import { Event } from '@all-live';

const BottomTabBar: React.FC<BottomTabBarProps> = ({ navigation, state }) => {
  const onTabPressHandler = useCallback(
    (currIdx: number, idx: number) => () => {
      if (currIdx !== idx) {
        navigation.navigate(state.routes[idx].name);
        return;
      }
      if (currIdx === BOTTOM_TABS.HOME_TAB_SCREEN) {
        // ë‘ë²ˆ ì—°ì†ìœ¼ë¡œ ê°™ì€ íƒ­ì„ íƒ­í•˜ëŠ” ê²½ìš° ì´ë²¤íŠ¸ ë°œìƒ
        Event.emit('scrollFlatListToTop');
      }
    },
    [],
  );
  // ìƒëµ
```

ë¦¬ìŠ¤íŠ¸ ì»´í¬ë„ŒíŠ¸ì—ì„  ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆë¥¼ ë“±ë¡í•´ì¤€ë‹¤.

```JS
import { Event } from '@all-live';

const AllTalentList: FC<AllTalentListProps> = memo(({ navigation }) => {
  const flatListRef = useRef<FlatList>(null);

  const onScrollToTopHandler = useCallback(() => {
    flatListRef.current?.scrollToOffset({ animated: true, offset: 0 });
  }, []);

  useEffect(() => {
    // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
    Event.addEventListener('scrollFlatListToTop', onScrollToTopHandler);
    return () => {
      // í´ë¦°ì—…
      Event.removeEventListener('scrollFlatListToTop');
    };
  }, []);

  // ìƒëµ
```

ë™ì‘ì´ ì˜ë˜ëŠ”ê±¸ í™•ì¸í•˜ê³  ë‚˜ì„œ íƒ€ì… ì ìš©ì„ ì‹œì‘í–ˆë‹¤.

ëª©í‘œëŠ” ì•„ë˜ì™€ ê°™ë‹¤.

1. ì´ë²¤íŠ¸ ì´ë¦„ ê°•ì œ ì‹œ

2. ì´ë²¤íŠ¸ ì´ë¦„ì— ë”°ë¼ ì½œë°±ì— ì¸ìê°€ ìˆëŠ” ê²½ìš° ì¸ì íƒ€ì… ì •ì˜

ì½”ë“œê°€ ê·¸ë ‡ê²Œ ê¸¸ì§€ ì•Šì•„ì„œ ì „ì²´ì½”ë“œë¥¼ ì˜¬ë¦¬ìë©´

```TS
// ì—¬ê¸° ì¸í„°í˜ì´ìŠ¤ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì¸ì íƒ€ì…ì„ ê²°ì • í•´ì¤€ë‹¤.
interface CustomEvents {
  // ì´ë²¤íŠ¸ ì´ë¦„: ì¸ì íƒ€ì…
  scrollFlatListToTop: undefined;
}

type Callback<T> = (args: T | Partial<T>) => Promise<void> | void;
type EventNames = Extract<keyof CustomEvents, string>;

class EventClass {
  private static Listeners = new Map();

  static addEventListener<EventName extends keyof CustomEvents = EventNames>(
    name: EventName,
    callback: Callback<CustomEvents[EventName]>,
  ) {
    const [isNameString, isCallbackFn, isExists] = [
      typeof name === 'string',
      typeof callback === 'function',
      EventClass.Listeners.has(name),
    ];

    if (!isNameString || !isCallbackFn || isExists) return;

    EventClass.Listeners.set(name, callback);
  }

  static removeEventListener(name: EventNames) {
    if (typeof name !== 'string') return false;
    return EventClass.Listeners.delete(name);
  }

  static removeAllEventListeners() {
    EventClass.Listeners.clear();
  }

  static emit<EventName extends keyof CustomEvents = EventNames>(name: EventName, args?: CustomEvents[EventName]) {
    const callback = EventClass.Listeners.get(name);

    if (typeof callback === 'function') {
      callback(args);
    }
  }
}

export default EventClass;
```

ì™€ ê°™ì´ í•´ì£¼ì—ˆê³  íƒ€ì… ì ìš©ì´ ì˜ ë˜ê³  ìˆëŠ”ì§€ í™•ì¸ í•´ë³´ì•˜ë‹¤.

íƒ€ì…ì´ ì˜ ì ìš© ë˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸ í•˜ê¸° ìœ„í•´ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì•„ë˜ì™€ ê°™ì´ ë³€ê²½

```TS
interface CustomEvents {
  scrollFlatListToTop: { myParam: number };
}
```

**emit í•˜ëŠ” ë¶€ë¶„**

<div class="center">
  <img src ="./img/type_test1.png" width="100%" height="auto">
</div>

**callback ë“±ë¡í•˜ëŠ” ë¶€ë¶„**

<div class="center">
  <img src ="./img/type_test2.png" width="100%" height="auto">
</div>

ì˜ëœë‹¤ ã…ã…

### ê²°ê³¼

ê±°ì˜ ë‡Œí”¼ì…œë¡œ êµ¬í˜„í•´ì„œ ì´ë ‡ê²Œ í•˜ëŠ”ê²Œ ë§ëŠ”ì§€ ëª¨ë¥´ê² ëŠ”ë° ê¸°ëŠ¥ì€ ëŒ€ì¶© í‰ë‚´ë‚¸ê±° ê°™ë‹¤.

<div class="center">
  <img src ="./img/custom_events.gif.gif" width="300" height="600">
</div>

## Note 3. Toast ë§Œë“¤ê¸°

Toast Modal ì„ ì»¤ìŠ¤í…€í•˜ê²Œ ì œì‘í•´ì„œ ì‚¬ìš©í•˜ê³  ìˆëŠ”ë° ë¬¸ì œì ì´ ìˆì—ˆë‹¤.

### ë¬¸ì œì  ğŸš¨

Toast Modal ì´ ë– ìˆëŠ” ë™ì•ˆ í™”ë©´ì„ ì œì–´í•˜ì§€ ëª»í•œë‹¤.

ë¬¸ì œê°€ ë°œìƒí•œ ì´ìœ ëŠ” `navigation` ì„ ì´ìš©í•´ì„œ **transparent modal** ë¡œ í™”ë©´ ì´ë™ì„ í•´ì„œ í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ êµ¬í˜„ì„ í–ˆëŠ”ë° ì•„ë˜ ìš”êµ¬ì‚¬í•­ì„ ì‰½ê²Œ ë§Œì¡±í•˜ê¸° ìœ„í•´ì„œì˜€ë‹¤.

### ìš”êµ¬ì‚¬í•­ ğŸ’­

    âœ… Toast Modal ì´ ìƒê²¼ë‹¤ê°€ ì¼ì •ì‹œê°„ ì´í›„ ìë™ìœ¼ë¡œ ì‚¬ë¼ì ¸ì•¼í•¨
    âœ… ì• ë‹ˆë§¤ì´ì…˜ (fade in, out) íš¨ê³¼ê°€ ìˆì–´ì•¼í•¨
    âœ… í™”ë©´ ë’¤ì— ì»¨í…ì¸ ê°€ ë³´ì—¬ì•¼ í•¨
    âŒ í™”ë©´ ì œì–´ê°€ ê°€ëŠ¥í•´ì•¼í•¨ â†’ ë¬¸ì œ ë°œìƒğŸ˜±

4ë²ˆ ë¬¸ì œë¥¼ ì¼ë‹¨ ëƒ…ë‘ê³  1ì°¨ ë°°í¬ë¥¼ í–ˆëŠ”ë° ì´ì œ í•´ê²°í•˜ê¸° ìœ„í•œ ë°©ë²•ì„ ìƒê°í•´ë³´ì•˜ë‹¤.

### í•´ê²°ë°©ì•ˆ ğŸ¤”

ê¸°ì¡´ ë°©ì‹ì€ ì•„ë˜ì™€ ê°™ì´ navigation ì„ í†µí•œ í™”ë©´ ì´ë™ì´ì˜€ë‹¤. í•´ë‹¹ ë°©ì‹ìœ¼ë¡œëŠ” ì• ë‹ˆë©”ì´ì…˜ì„ ë”°ë¡œ ì½”ë”©í•˜ì§€ ì•Šê³  êµ¬í˜„í•  ìˆ˜ ìˆì–´ì„œ í•˜ì˜€ëŠ”ë° 4ë²ˆ ë¬¸ì œë¥¼ í•´ê²° í•  ìˆ˜ ì—†ì—ˆë‹¤.

```JS
navigation.navigate('TOAST_MODAL', { body: TOAST_MESSAGES.TALENT.LIKED });
```

ì œì¼ ì²˜ìŒ ë– ì˜¬ë¦° í•´ê²°ë°©ì•ˆì€ navigation ì„ í†µí•œ í™”ë©´ ì´ë™ì´ ì•„ë‹Œ ì‘ì€ ì»´í¬ë„ŒíŠ¸ë¥¼ ë„ì›Œì£¼ëŠ” ë°©ì‹ìœ¼ë¡œ í•´ê²° í•˜ê³ ì í•˜ì˜€ë‹¤.

ë¶€ëª¨ ì»´í¬ë„ŒíŠ¸ê°€ ìì‹ ì»´í¬ë„ŒíŠ¸ë¥¼ ì œì–´í•´ì•¼í•˜ê¸° ë•Œë¬¸ì— **`useImperativeHandle`** ì„ í™œìš© í•˜ì˜€ë‹¤.

ì „ì²´ ì½”ë“œëŠ” ì•„ë˜ì™€ ê°™ë‹¤.

```tsx
type Timer = ReturnType<typeof setTimeout>;

const TOAST_TIMEOUT_IN_MS = 1200;

const Toast = forwardRef<ToastRef>((_, ref) => {
  const timer = useRef<Timer | null>(null);
  const isAnimating = useRef<boolean>(false);
  const { bottomInset } = useSafeArea();
  const animation = useRef(new Animated.Value(0)).current;

  const [body, setBody] = useState<string | null>(null);
  const [margin, setMargin] = useState<number>(0);

  const doneAnimatingCallback = useCallback(() => {
    isAnimating.current = false;
    setBody(null);
  }, []);

  const timeOutHandler = useCallback(() => {
    Animated.timing(animation, { toValue: 0, duration: 200, useNativeDriver: true }).start(
      doneAnimatingCallback
    );
  }, []);

  const onShowHandler = useCallback((toastProps: ToastProps) => {
    const { timeOutInMs = TOAST_TIMEOUT_IN_MS, body: toastBody } = toastProps;
    // ì´ë¯¸ ë‹¤ë¥¸ toast ê°€ animating ì¤‘ì¸ ê²½ìš° ë‹¤ë¥¸ toast ëŠ” ì–µì œ
    // 1. íì— ë„£ì–´ì„œ í•˜ë‚˜ì”© ì²˜ë¦¬í• ê¹Œ ìƒê°í–ˆì§€ë§Œ ì• ë§¤í•´ì„œ ì¤‘ë‹¨
    // 2. ê¸°ì¡´ toast ë¥¼ ì·¨ì†Œí•˜ê³  ìƒˆë¡œìš´ toast ë¥¼ ë„ì›Œì£¼ëŠ” ë°©ì‹ë„ ê°€ëŠ¥í• ë“¯
    if (isAnimating.current) return;
    isAnimating.current = true;
    setBody(toastBody);
    Animated.timing(animation, { toValue: 1, duration: 400, useNativeDriver: true }).start();
    timer.current = setTimeout(timeOutHandler, timeOutInMs);
  }, []);

  const imperativeHandler = useCallback(
    () => ({
      show: onShowHandler
    }),
    []
  );

  const onBodyLayoutHandler = useCallback((event: LayoutChangeEvent) => {
    // container left margin ì„ ê³„ì‚°í•˜ê¸° ìœ„í•¨
    const containerWidth = event.nativeEvent.layout.width;
    if (typeof containerWidth !== 'number') return;
    setMargin(Math.floor((DIMENSIONS.WIDTH - containerWidth) / 2));
  }, []);

  useImperativeHandle(ref, imperativeHandler, []);

  return (
    <>
      {body && (
        <ToastStyle.Container
          as={Animated.View}
          leftMargin={margin}
          bottomInset={bottomInset}
          style={{ opacity: animation }}
        >
          <ToastStyle.BodyView onLayout={onBodyLayoutHandler}>
            <GlobalText.TextSmall color="whiteColor">{body}</GlobalText.TextSmall>
          </ToastStyle.BodyView>
        </ToastStyle.Container>
      )}
    </>
  );
});

const ToastStyle = {
  Container: Styled.View<SafeAreaInsets & { leftMargin: number }>`
    position: absolute;
    bottom: ${({ bottomInset = 0, theme }) => theme.bottomTabBarHeight + bottomInset + 16}px;
    margin-left: ${({ leftMargin }) => leftMargin}px;
  `,
  BodyView: Styled.View`
    border-radius: 8px;
    background-color: #000000aa;
    padding: 16px;
  `
};
```

ê°ê° ìš”êµ¬ì‚¬í•­ì— ëŒ€í•œ êµ¬í˜„ì€ ì•„ë˜ì™€ ê°™ì´ ì§„í–‰í•¨!

1. Toast Modal ì´ ìƒê²¼ë‹¤ê°€ ì¼ì •ì‹œê°„ ì´í›„ ìë™ìœ¼ë¡œ ì‚¬ë¼ì ¸ì•¼í•¨

   `imperativeHandler` ë¥¼ í†µí•´ ë¶€ëª¨ ì»´í¬ë„ŒíŠ¸ì—ì„œ **onShowHandler** ë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆë„ë¡ ì„¸íŒ…,

   **setBody** ë¥¼ í†µí•´ ë·°ê°€ ë‚˜íƒ€ë‚˜ë„ë¡ í•˜ê³  **Animated API** ë¥¼ í†µí•´ opacity ì• ë‹ˆë©”ì´ì…˜ìœ¼ë¡œ fade in íš¨ê³¼ êµ¬í˜„

   animation ì€ useNativeDriver ë¥¼ í†µí•´ ë„¤ì´í‹°ë¸Œë¡œ ë„˜ê¹€

   setTimeOut ì„ í†µí•´ fade out animation í˜¸ì¶œ í›„ ì½œë°±ìœ¼ë¡œ ë‹¤ìŒ ì• ë‹ˆë©”ì´ì…˜ ê°€ëŠ¥í•˜ë„ë¡ isAnimating ê°’ ì—…ë°ì´íŠ¸

2. ì• ë‹ˆë§¤ì´ì…˜ (fade in, out) íš¨ê³¼ê°€ ìˆì–´ì•¼í•¨

   ìœ„ì— ì„¤ëª…í•œ **Animated API** ë¡œ í•´ê²°!

3. í™”ë©´ ë’¤ì— ì»¨í…ì¸ ê°€ ë³´ì—¬ì•¼ í•¨

   ```jsx
   const CategoryTabScreen: React.FC<CategoryTabScreenProps> = ({ navigation }) => {
     // toast ì œì–´í•˜ê¸° ìœ„í•œ ref
     const toastRef = useRef < ToastRef > null;

     const likePressHandler = useCallback(
       (subCategoryLikeInfo: SubCategoryLikeInfo) => async () => {
         try {
           // ìƒëµ
           // show handler í˜¸ì¶œ
           toastRef.current?.show({
             body: getCategoryLikeToastBody(subCategoryLikeInfo, result)
           });
         } catch (error) {
           // ìƒëµ
         }
       },
       []
     );

     return (
       <SafeAreaView>
         <OtherComponents likePressHandler={likePressHandler} />
         {/* SafeAreaView ì—ì„œ ê°€ì¥ ì•ìª½ì— ë…¸ì¶œ ë˜ë„ë¡ */}
         <Toast ref={toastRef} />
       </SafeAreaView>
     );
   };
   ```

4. í™”ë©´ ì œì–´ê°€ ê°€ëŠ¥í•´ì•¼í•¨ ğŸ‘‰ í•µì‹¬ ì´ìŠˆ!

Container ì»´í¬ë„ŒíŠ¸ë¥¼ width: 100% ë¡œ Text ì»´í¬ë„ŒíŠ¸ë¥¼ margin: 0 auto ì™€ ê°™ì´ í•´ì¤„ ìˆ˜ ìˆì§€ë§Œ ì•„ë˜ ê·¸ë¦¼ê³¼ ê°™ì€ ì˜ì—­ í„°ì¹˜ê°€ ë¶ˆê°€ëŠ¥ í•´ì§„ë‹¤.

<div class="center">
  <img src ="./img/toast.png" width="300" height="auto">
</div>

ë”°ë¼ì„œ container width ëŠ” í† ìŠ¤íŠ¸ ê°€ë¡œ ê¸¸ì´ì— ë”± ë§ë„ë¡ í•˜ê³  margin-left ì†ì„±ì„ ë™ì ìœ¼ë¡œ ì¡°ì ˆ í•´ì£¼ëŠ” ë°©í–¥ìœ¼ë¡œ ì§„í–‰í–ˆë‹¤. í† ìŠ¤íŠ¸ë¥¼ ì œì™¸í•œ ëª¨ë“  ì˜ì—­ í„°ì¹˜ê°€ ê°€ëŠ¥í•˜ê²Œ í•˜ë„ë¡ í•˜ê¸° ìœ„í•¨ì´ë‹¤.

`onBodyLayoutHandler` ë¥¼ í†µí•´ body ì— ë”°ë¥¸ ë·°ì˜ ê°€ë¡œ ê¸¸ì´ë¥¼ ê³„ì‚°í•´ì„œ container margin-left ê°’ì„ ë™ì ìœ¼ë¡œ ì¡°ì ˆ.

<div class="center">
  <img src ="./img/toast_screen.png" width="300" height="auto">
</div>

ì˜ ì ìš©ëœ ëª¨ìŠµ. ë~!

~~ê°œë°œì ì…ì¥ì—ì„  ë§ì€ ë³€í™”ê°€ ìˆì—ˆì§€ë§Œ ì‚¬ìš©ìë“¤ì€ í•´ë‹¹ ì´ìŠˆê°€ ìˆëŠ”ì§€ë„ ëª¨ë¥¼ë•Œê°€ ë§ë‹¤..ã…ã…~~

ê·¸ë˜ë„ ë‚˜ë§Œ ë§Œì¡±í•˜ë©´ ë¨

<style>
.center {
  width: 100%;
  display: flex;
  justify-content: space-evenly;
  flex-direction: row;
  flex-wrap: wrap;
}
</style>
